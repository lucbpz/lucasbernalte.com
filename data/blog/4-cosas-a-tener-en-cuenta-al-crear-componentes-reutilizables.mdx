---
title: '4 pasos para crear una buena API de componente reusable'
date: '2020-12-18T05:35:07.322Z'
summary: 'C칩mo crear componentes reutilizables con React para un cat치logo de componentes'
image: '/static/images/api-component/user-interface.jpg'
---

![User Interface](/static/images/api-component/user-interface.jpg)

# 4 pasos para crear una buena API de componente reusable

Creando componentes reusables siempre empiezo dudando de qu칠 API deber칤a tener - en un componente hablamos de entradas y salidas, props que entran y eventos que salen - o en el caso de React, m칠todos que ejecutan.

## TL;DR

- Evita estados imposibles
- Deja espacio para la personalizaci칩n.
- Piensa en la Developer Experience (DX).
- Evita abstracciones innecesarias

En este caso, el "Too long, didn't read" nos sirve de 칤ndice, ya que vamos a desarrollar cada punto por separado.


## 1. Evita estados imposibles

Este apartado est치 fuertemente inspirado en la charla ["Making Impossible States Impossible" de Richard Feldman.](https://www.youtube.com/watch?v=IcgmSRJHu_8) B치sicamente consiste en declarar un modelo de datos que no permite que estados no compatibles colisionen. Si utilizas un lenguaje tipado, te beneficiar치s mucho m치s de esto, pero tambi칠n podemos hacer esto con JavaScript. 

En [este otro art칤culo](https://kentcdodds.com/blog/make-impossible-states-impossible), Kent C. Dodds lo pone de manifiesto en un ejemplo tal y como lo buscamos, un estado que hemos creado en un componente de React, y que da lugar a posibles estados que no deber칤an coexistir. 

Si tenemos una notificaci칩n que puede ser de tipo "info", "warning" y "error", el componente puede ser:

```jsx
const Notification = ({info, warning, error, message}) => {
	if (info) {
		...
	}
	return (
	...
};
```

as칤, podr칤amos usar el componente de diferentes formas:

```jsx
<Notification error message="error!" />
<Notification info message="info!" />
```

Sin embargo, estamos dejando al usuario de nuestro componente la posibilidad de utilizarlo mal, colisionando ciertas props sin saber qu칠 va a pasar. 쯈u칠 pasar치 cuando el usuario lo utilice as칤?

```jsx
<Notification error info message="mensaje" />
```

Esto que acabamos de ver es algo a evitar cuando estamos creando un componente reutilizable, y m치s si lo van a utilizar personas de fuera de nuestro equipo, donde debemos dejar un componente completamente testeado y documentado. Tenemos la opci칩n de crear un test para indicar cu치l es el comportamiento correcto en este caso:

```jsx
describe('when error and info are set', () => {
	it('should...')
};
```

O mejor, evitar ese estado, haciendo que "error", "info" y "warning" sean valores de un `type`:

```jsx
<Notification type="warning" message="warning message!" />
```

Como dice Richard Fieldman en la charla que mencion치bamos

> Testear est치 bien, pero lo imposible est치 mejor

## 2. Deja espacio para la personalizaci칩n

Personalizar los componentes que usamos de alguna librer칤a es algo muy com칰n, ya sea simplemente personalizar los estilos de un componente, o personalizar alguna parte de la interfaz, sustituyendo por ejemplo un texto por un componente propio. 

Este punto es muy abierto y puede sonar poco definido, ya que depender치 del framework que estemos utilizando, bien podemos usar `<slot>` si estamos usando WebComponents, o en el caso de React, hacer uso del `children` o directamente dejar una prop abierta para el componente a renderizar...

Lo que debemos saber de este punto es que puede que el usuario de nuestro componente lo utilice tal cual, o por su caso de uso necesite un punto extra de flexibilidad.

Un ejemplo muy b치sico ser칤a un componente que renderiza un listado de items. El componente puede renderizar el item como si fuera cualquier cosa, as칤 que podr칤amos pasar un listado de items que en realidad ser칤a un listado de JSX que renderizar치, incluso cada uno puede tener sus `onClick` correspondientes, haciendo que un componente del estilo:

```jsx
<RenderList data={messages}>
	<Message />
	<HiddenMessages />
</RenderList>
```

acepte en su variable data tanto:

```jsx
const messages = new Array(20).fill().map((_, i) => ({
  content: `Hello, this is message ${i} here. Cool, huh?`
}));
```

como:

```jsx
const messages = new Array(20).fill().map((_, i) => ({
  content: <button key={i} onClick={console.log}>button {i}</button>
}));
```

## Evita abstracciones innecesarias

Somos desarrolladores. Buscamos siempre c칩mo aportar lo m치ximo con abstracciones para permitir todos los casos de uso posibles. A veces esto nos puede llevar a pensar cosas del estilo: bueno, si hago X, esta feature es gratis, as칤 que por qu칠 no).

Sin embargo esta abstracci칩n que en teor칤a hacemos para ahorrar tiempo al usuario y darle lo m치ximo, a veces puede ser innecesaria e incluso perjudicial, haciendo que sea demasiado compleja para un usuario que est치 inici치ndose con nuestro componente, y en lugar de ayudarle, si no consigue lo que ha venido a hacer, incluso desista y no lo use.

> [Duplication is far cheaper than the wrong abstraction](https://sandimetz.com/blog/2016/1/20/the-wrong-abstraction).

Siguiendo el patr칩n que se comenta en esa charla, y tomando como el ejemplo del componente anterior que renderiza una lista, podemos seguir el siguiente proceso mental que nos lleva el desarrollo del mismo:

1. Desarrollamos componente que permite renderizar una lista de items.
2. Creamos la abstracci칩n para que se pueda pasar contenido JSX.
3. Hay un nuevo requerimiento, cada item ir치 con un icono, y la mayor칤a de las veces ser치 el mismo.
4. Creamos una abstracci칩n para poder pasar un icono que se repetir치 con cada item. Ahora nuestro componente se usar칤a:

    ```jsx
    <RenderList data={messages} icon="fa-file">
    	<Message />
    	<HiddenMessages />
    </RenderList>
    ```

5. Esta abstracci칩n nos hace pensar en el tiempo que ahorramos con esa nueva prop.
6. Ahora pensamos qu칠 pasa si queremos diferentes iconos y refactorizamos para poder pasar `icons`:

    ```jsx
    <RenderList data={messages} icons={["fa-file", "fa-file", "fa-danger"]}>
    	<Message />
    	<HiddenMessages />
    </RenderList>
    ```

Esto nos ha llevado a una abstracci칩n que parece no ser la mejor a la hora de resolver el problema inicial, ya que el requisito de
renderizar tambi칠n un icono se pod칤a hacer desde el principio, pas치ndole al componente una lista de JSX personalizada.

> Lo que fue una abstracci칩n universal, ahora se comporta diferente para diferentes casos de uso. - Sandi Metz

## Piensa en la Developer eXperience

Crea los componentes para el usuario m치s importante del mundo - tu "yo del futuro".

Porque todo lo visto anteriormente no tiene por qu칠 ser para un usuario desconocido - puede ser para tu equipo y/o para ti. Y adem치s de pensar en la API, ten en cuenta que una parte del mantenimiento del software es la documentaci칩n y el testing, y con el tiempo nos olvidaremos de cosas si no las dejamos por escrito. Redacta una documentaci칩n que no d칠 lugar a dudas y tests que puedan ser usados como documentaci칩n, ya que por la sintaxis podemos hacer que se escriban de forma que describan su comportamiento (adem치s es como se deber칤a testear).

La idea es tardar lo m칤nimo en entender c칩mo funciona el componente.

Porque la documentaci칩n y los tests pueden hacer que "triunfe" nuestro componente, o pueden "romperlo". Cuando un desarrollador est치 usando tu componente por primera vez, lo primero que har치 ser치 leer la documentaci칩n. Si tu gu칤a inicial no est치 clara, puede que pierdas a este usuario. 

Tendemos a enfocarnos mucho en los detalles de implementaci칩n y perdemos la visi칩n de los desarrolladores que entran por primera vez y necesitan tener una visi칩n clara de lo que van a usar.

En definitiva, tambi칠n es nuestro trabajo asegurar que se han tenido en cuenta las necesidades del desarrollador.

Piensa en las veces que como desarrollador, cuando buscas un componente has seguido este proceso:
- Necesitas X
- Buscas y encuentras una librer칤a que en teor칤a parece que hace X.
- No consigues el resultado que buscas, y desistes, desinstalando la librer칤a y buscando otra o fabric치ndola t칰 mismo.

## Conclusiones

Espero que este art칤culo te ayude a la hora de crear tu siguiente componente dentro de un cat치logo o a la hora de crear un componente de forma aislada o incluso para crear un cat치logo de componentes completo. Estos criterios son los que tengo como fundamento, aunque hay casos especiales y tampoco hay que tener un plan para seguirlo 100% a la perfecci칩n, pero con estos 4 puntos seguro que ves tu componente de otra manera 游땕. Buena suerte!

```jsx
expect(newComponent).toBeBetterThan(oldComponent)
```