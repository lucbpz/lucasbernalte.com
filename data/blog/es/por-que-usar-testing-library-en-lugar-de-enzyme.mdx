---
title: 'Por qu√© usar Testing Library en lugar de Enzyme'
date: '2021-02-10T11:35:07.322Z'
summary: 'An√°lisis entre Enzyme y React Testing Library sobre c√≥mo renderizan los componentes y qu√© se puede hacer con ambas. Buenas pr√°cticas de testing.'
image: '/static/images/enzyme/lab-enzyme.jpg'
---

![Testing Library vs Enzyme](/static/images/enzyme/lab-enzyme.jpg)
<span>Photo by <a href="https://unsplash.com/@nci?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">National Cancer Institute</a> on <a href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></span>

# Por qu√© usar Testing Library en lugar de Enzyme

La librer√≠a de testing creada por Kent C. Dodds y mantenida por su comunidad, Testing Library (no pod√≠an haber elegido un mejor nombre) ha tenido un tremendo √©xito en la comunidad de desarrollo y aun empezando solo con React, ya existen Testing Libraries para Svelte, Vue, Angular, Cypress, etc. Antes de que existiera, los desarrolladores de React utilizaban Enzyme, creada por AirBnB, como su librer√≠a de testing.

En este art√≠culo voy a explicarte qu√© hacen ambas librer√≠as y por qu√© elegir Testing Library sobre Enzyme como tu librer√≠a de testing en tu stack de desarrollo.

# Enzyme

Enzyme es una librer√≠a de utilidades de Testing para React, que hace f√°cil la lectura del output de nuestros componentes, teniendo una API intuitiva y flexible.

## ¬øC√≥mo renderiza Enzyme un componente?

- Shallow rendering: para limitar el test de un componente a su propia unidad, es decir, un nivel de profundidad, sin incluir nada de lo que est√° por debajo.

```jsx
const MyComponent = () => {
	return (
		<div>
			<h1>Title</h1>
			<Subcomponent type="info" />
		</div>
	)
};

// output de shallow(<MyComponent />) no renderiza Subcomponent
/*
<div>
	<h1>Title</h1>
	<Subcomponent type="info" />
</div>
*/
```

- Full DOM Rendering: Es la √∫nica opci√≥n de Enzyme que monta el componente, as√≠ que tiene que hacerlo en al menos, algo parecido a un browser, como el JSDOM.
- Static Rendering API: Genera HTML a partir del √°rbol de React de tu componente, para poder analizar la estructura HTML resultante.

## ¬øQu√© podemos comprobar y testear con Enzyme?

- Podemos interactuar con los elementos de dentro de nuestro componente como sus props y m√©todos, incluso hacer que se actualice, de forma imperativa:

```jsx
const wrapper = mount(<SomeComponent />);
act(() => wrapper.prop('handler')());
wrapper.update();
```

- Podemos tambi√©n setear sus props con `setProps` o sus estado, con `setState`.

```jsx
const wrapper = mount(<Foo name="foo" />);
expect(wrapper.find('.foo')).to.have.lengthOf(1);
expect(wrapper.find('.bar')).to.have.lengthOf(0);
wrapper.setProps({ name: 'bar' });
expect(wrapper.find('.foo')).to.have.lengthOf(0);
expect(wrapper.find('.bar')).to.have.lengthOf(1);
```

- Simular algunos eventos.

```jsx
wrapper.find('a').simulate('click');
```

- Desmontar el componente.

```jsx
wrapper.unmount();
```

# Testing Library

Testing Library es un set de utilidades de testing simple y completo que promueve las buenas pr√°cticas del testing. Es una ayuda para testear User Interfaces de forma centrada en el usuario.

## ¬øC√≥mo renderiza React Testing Library un componente?

Hablamos concretamente de React Testing Library, y no de Testing Library a secas, para hacer la comparaci√≥n con Enzyme, ya que en otro framework, el renderizado ser√≠a diferente. React Testing Library usa el mismo m√©todo que usamos para renderizar un componente en nuestra aplicaci√≥n, `ReactDOM.render`.

Esto hace que cuando se renderiza un componente en el test, pasa por los mismos ciclos de vida que pasa cuando se renderiza "en la vida real" ya que se hacen de la misma forma.

React Testing Library te provee de una funci√≥n `render` que har√° este renderizado por ti y te devolvera un tipo de dato que contiene queries para hacerle a este componente.

[Aqu√≠ puedes ver d√≥nde se realiza el `render` dentro del c√≥digo de RTL](https://github.com/testing-library/react-testing-library/blob/master/src/pure.js#L63)

## ¬øQu√© podemos comprobar y testear con Testing Library?

Testing Library tiene como premisa evitar testear implementaciones, as√≠ que lo que podemos hacer es interactuar con el DOM o en React, con el JSDOM. Esto implica que podemos:

- Comprobar que existe un elemento con queries directamente

```jsx
document.querySelector('.component-class');
```

- Lanzar eventos, al igual que se lanzan eventos desde el DOM cuando el usuario interact√∫a con el componente.

```jsx
fireEvent.click(screen.getByRole('button'))
```

- Comprobar que existe un elemento con las queries recomendadas, para seguir las buenas pr√°cticas, y que las encontramos como respuesta del m√©todo render o dentro de un objeto screen, que contiene todo lo que renderizamos en el test. Esto podemos hacerlo de forma s√≠ncrona, o as√≠ncrona. El m√©todo as√≠ncrono, en realidad internamente, lo intentar√≠a ejecutar varias veces, teniendo un timeout configurable a nivel global o por ejecuci√≥n.

```jsx
render(<MyComponent />);
screen.getByText('title'); // s√≠ncrono. Lanza error si no existe.
screen.queryByText('title'); // s√≠ncrono. Devuelve null si no existe.
await screen.findByText('title'); // as√≠ncrono.
```

- Comprobar que un elemento ha dejado de existir en el DOM:

```jsx
await waitForElementToBeRemoved(() => screen.queryByText('the mummy'))
```

Para saber qu√© query utilizar en cada momento, su documentaci√≥n nos dice cu√°les son las m√°s recomendadas: [https://testing-library.com/docs/queries/about#priority](https://testing-library.com/docs/queries/about#priority)

Si necesitamos debuggear un test porque no sabemos qu√© se est√° renderizando y tenemos un √°rbol demasiado grande, no podremos ver bien el resultado en la terminal y se acabar√° cortando el √°rbol. Para ello, han desarrollado una herramienta visual, [Testing Playground](https://testing-playground.com/) donde podemos visualizar nuestro componente (aunque no tenga los estilos demasiado bien) y ver el √°rbol completo. Para ello, dentro de nuestro test ponemos:

```jsx
screen.logTestingPlaygroundURL();
```

y ya nos saldr√° por consola un link que nos llevar√° a dicha herramienta con nuestro HTML.

# Por qu√© la comunidad est√° migrando a Testing Library

Si comparamos la opci√≥n de Testing Library con el "mount" de Enzyme, ser√≠an las m√°s similares. ¬øPor qu√© entonces la comunidad est√° eligiendo una frente a la otra?

Pues bien, antes de contestar a esta pregunta, es necesario hacerse otra pregunta.

¬øCu√°ntos usuarios tiene nuestro componente?

En la mayor√≠a de los casos, un componente tendr√° dos usuarios:

- Por un lado, el usuario final, que ve nuestra aplicaci√≥n e interact√∫a con √©l.
- El desarrollador que mantiene el c√≥digo y puede modificarlo, o reutilizarlo en otro sitio.

Cuando agregamos opciones como `shallow` rendering, o mocks para testear nuestro componente de forma aislada, estamos creando un tercer usuario de nuestro componente: el test. Esto implica que este test necesitar√° mantenimiento, estar√° de alguna medida enlazado con la implementaci√≥n, y cuando √©sta cambie, tendremos que cambiar nuestro test. Nuestro c√≥digo se vuelve mucho m√°s mantenible cuando s√≥lo tenemos dos usuarios.

Testing Library directamente no da una opci√≥n `shallow` precisamente porque [su premisa es hacer tests de una forma "Behavior Driven"](https://www.giffgaff.io/tech/react-test-driven-development/).  Esta forma de testear, aunque parece ser "opinionated", es en realidad la forma m√°s efectiva de testear User Interfaces, [evitando testear implementaciones](https://kentcdodds.com/blog/testing-implementation-details/). 

> "We try to only expose methods and utilities that encourage you to write tests that closely resemble how your React components are used."

Tanto es as√≠, que pas√≥ a ser la primera librer√≠a de testing recomendada en la documentaci√≥n oficial de React. 

AirBnB, el propio creador de Enzyme, vio el potencial y comenz√≥ su adopci√≥n, manteniendo de momento ambas librer√≠as (ten√≠an m√°s de 17000 tests en Enzyme, imposible migrarlo en un commit...). Y [en marzo de 2020 AirBnB anunci√≥ que iban a hacer el transfer del ownership de la librer√≠a,](https://www.infoq.com/news/2020/03/airbnb-drops-ownership-enzyme/) aunque pensaban seguir contribuyendo.

Algunas de los repositorios Open Source m√°s grandes en Github como Storybook o Gatsby ya usan React Testing Library, y algunas como Material UI est√°n desde abril en proceso de migraci√≥n.

React va a d√≠a de hoy por la v17, y Enzyme, al basarse en la propia implementaci√≥n de React para poder renderizar, necesita de un "adapter" para funcionar, y todav√≠a no han sacado ninguno oficial para la v17, teniendo que [instalarse un adapter no-oficial](https://www.npmjs.com/package/@wojtekmaj/enzyme-adapter-react-17) para que pueda funcionar con la √∫ltima versi√≥n.

# Mi recomendaci√≥n

Cada librer√≠a tiene su contexto, y hay que entender el contexto y la premisa con la que fueron creadas. La adopci√≥n de testear comportamientos por parte de la comunidad es muy grande y es la forma de aportar m√°s valor con tus tests. Yo recomiendo elegir Testing Library para evitar caer en la tentaci√≥n y testear cosas que no deber√≠as, como props que se pasan de un sitio a otro (estar√≠as testeando la propia implementaci√≥n de React). Adem√°s proporciona una API muy buena e intuitiva para comprobar nuestra UI incluso de forma as√≠ncrona, y la comunidad est√° haciendo un gran trabajo, extrayendo el core de la librer√≠a y sacando a utilidades toda su API para que pueda ser utilizada con cualquier framework. Y tambi√©n est√°n desarrollando `user-event` una librer√≠a que simula los eventos reales que realizar√≠a un usuario como "click", "doble-click", "escribir", etc. 

---

Si te ha gustado este art√≠culo, puedes ayudarme d√°ndole visibilidad, comparti√©ndolo en twitter y sigui√©ndome para estar al tanto del contenido que voy creando. Si ves que hay alguna errata y quieres colaborar, puedes directamente [hacer una Pull Request](https://github.com/lucbpz/lucasbernalte.com).

üôã‚Äç‚ôÇÔ∏è Happy Testing!